<!DOCTYPE html>
<html>

<head>
    <title>Ryan Chernoff Prortfolio</title>
    <link rel="stylesheet" href="index.css" type="text/css" />
</head>

<body>
    <h1>Ryan Chernoff</h1>
    <h2>About Me</h2>
    <hr>
    <p>Lorum impsum</p>
    <h2>Projects</h2>
    <hr>
    <h3>Text Based Choose Your Own Adventure Game Engine</h3>
    <p>
        &emsp;&emsp;In 2019, I began my exploration of file IO with the development of a Text Based Choose Your Own Adventure
        Game Engine. In order to make writing stories as simple as possible, each part of the story was stored in a file which
        the game engine would parse and display to the user. The file would also include what options the user had and what
        files to open next when an option was selected. However, I wanted every part of the user interface to be customizable so
        I added special variables that could be set within a file to update attributes like the background color, button color,
        text color, and text speed. I also added special syntax so that custom variables can be made and set to arbitrary values
        that can later be displayed as part of the UI. Although there are much better text based game engines out there, this
        project ultimately taught me a lot about file IO and makes for a one of a kind storytelling experience.
    </p>
    <h3>N.E.A.T. Neural Network</h3>
    <p>
        &emsp;&emsp;My exploration of Artificial Intelligence led me to explore different evolutionary algorithms for training
        neural networks. After reading Stanley and Miikkulainen's paper on
        <a href="https://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf" target="_blank">Evolving Neural Networks through
            Augmenting Topologies</a>
        and having just learnt C, I decided to implement the algorithm. Neural networks were represented using linked lists of
        genes that specified the types of connections that the network had. These genes could then be efficiently combined and
        mutated just as in the paper. The algorithm can then create generations of networks and selectively combine the most fit
        ones until the threshold for success is reached. In order to prevent networks with different successful approaches from
        interfering with each other, when two networks are too different from each other, they are classified is different
        species and can't reproduce. This gives more complex topologies time to adapt before they are deemed unfit. This allowed
        for efficient topological innovation and created multiple successful networks capable of solving complex problems (such
        as XOR computation and weight balancing) with high accuracy. In implementing this algorithm, I learned a lot
        about neural networks and the importance behind efficient topology.
    </p>
    <h3>Singular Value Decomposition Calculator</h3>
    <p>
        &emsp;&emsp;While studying linear algebra, I came across the usefulness of Singular Value Decomposition (SVD) for both
        determining the principal components and pseudo-inverses of both real and complex matrices. To compute the SVD of a
        matrix, you need to compute all the square root of the eigenvalues of it multiplied with its transpose. To compute these
        eigenvalues I used the QR method which relies on deriving an orthonormal basis for the column space of a matrix. Then a
        similar matrix is produced by reversing the order of Q and R and the process is repeated until convergence. From there,
        the eigenvalues and their respective vectors can be extracted. This allows us to compute the SVD of the original matrix.
        This project let me utilize all my linear algebra skills to implement an incredibly useful algorithm for deriving
        important properties of matrices.
    </p>
    <h3>Virtual Cache Simulator</h3>
    <p>
        &emsp;&emsp;As part of my study of physical computer systems I learned about the various caches integral in
        ensuring processes run in a reasonable number of cycles. With my knowledge, I implemented a virtual cache that could be
        configured to emulate the functionality of any sized cache. The virtual cache could handle both load and save events at
        any location in memory. It would also keep track of the number of cache misses, hits, and evictions that occured. The
        variation of the cache I made utilized dirty bits to mark cache blocks that had been written to so that their value
        could be updated in memory upon eviction. It also kept track of the number of dirty bits that had been evicted and the
        number still in the cache. Implementing this simulator allowed me to gain a better understanding of how caches work
        and how important it is to utilize locality to avoid costly cache misses.
    </p>
    <h3>Dynamic Memory Allocator</h3>
    <p>
        &emsp;&emsp;While learning how processes manage memory, I implement C's malloc, calloc, realloc, and free functions to
        better understand how the heap is managed. My implementation used segregated free lists of varying block sizes to ensure
        good throughput when finding free memory to allocate. It also used best fit (finding the smallest possible block) to
        ensure good utilization of the heap. The design of the blocks took advantage of 0-length arrays in order to have
        variable block sizes. Each block was a union of a free block type and an allocated block type where free blocks held
        important information about its location in the free list (such as the address of the next block and the block size) and
        allocated blocks only held size information. When a block is freed it gets combined with any surrounding free blocks and
        added to the appropriate free list. Although my implementations are much simpler than their C library counterparts, I
        learned a lot about how allocated memory is managed and how the heap is kept at an incredibly efficient size.
    </p>
    <h3>Tiny Shell</h3>
    <p>
        Lorum impsum
    </p>
    <h3>HTTP Proxy</h3>
    <p>
        Lorum impsum
    </p>
    <h3>Cryptography Tool</h3>
    <p>
        Lorum impsum
    </p>
</body>

</html>